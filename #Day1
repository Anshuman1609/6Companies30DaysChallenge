Q1. Minimize the maximum of Two arrays :- 
    We have two arrays arr1 and arr2 which are initially empty. You need to add positive integers to them such that they satisfy all the following conditions:
    
     * arr1 contains uniqueCnt1 distinct positive integers, each of which is not divisible by divisor1.
     * arr2 contains uniqueCnt2 distinct positive integers, each of which is not divisible by divisor2.
     * No integer is present in both arr1 and arr2.
    Given divisor1, divisor2, uniqueCnt1, and uniqueCnt2, return the minimum possible maximum integer that can be present in either array.

 Solution :-  Using Binary Search
    class Solution {
        typedef long long ll;
    public:
        int minimizeSet(int div1, int div2, int count1, int count2) {
            int l = 1;
            int r = INT_MAX;
            int ans = -1;
            ll lcm = (ll) div1 * div2 / __gcd(div1, div2);
            while(l<=r){
                int mid = (l+((r-l) >> 1));
                int cnt1 = mid - mid/div1;
                int cnt2 = mid - mid/div2;
                ll combined = mid - mid/lcm;
                if(cnt1 >= count1 && cnt2 >= count2 && combined >= count1 + count2){
                    ans = mid;
                    r = mid - 1;
                }
                else{
                    l = mid + 1;
                }
            }
            return ans;
        }
    };







Q2. High-Access Employees :- 
    You are given a 2D 0-indexed array of strings, access_times, with size n. For each i where 0 <= i <= n - 1, access_times[i][0] represents the name of an employee, and access_times[i][1] represents the access time of that employee. All entries in access_times are within the same day.
    The access time is represented as four digits using a 24-hour time format, for example, "0800" or "2250".    
    An employee is said to be high-access if he has accessed the system three or more times within a one-hour period.
    Times with exactly one hour of difference are not considered part of the same one-hour period. For example, "0815" and "0915" are not part of the same one-hour period.
    Access times at the start and end of the day are not counted within the same one-hour period. For example, "0005" and "2350" are not part of the same one-hour period.
    Return a list that contains the names of high-access employees with any order you want.

Solution :- 
    class Solution {
public:
    vector<string> findHighAccessEmployees(vector<vector<string>>& access_times) {
        unordered_map<string, vector<int>> mp;
        for (auto& it : access_times) {
            int time = stoi(it[1]);
            mp[it[0]].push_back(time);
        }
        for (auto& it : mp) {
            sort(it.second.begin(), it.second.end());
        }
        vector<string> ans;
        for (auto& it : mp) {
            vector<int>& times = it.second;
            for (int i = 2; i < times.size(); i++) {
                if (times[i] - times[i - 2] < 100) {
                    ans.push_back(it.first);
                    break;
                }
            }
        }
        return ans;

    }
};
